Souper `Inst` Tutorial and Reference
====================================

The Souper `Inst` format is a verifiable textual pattern matching
representation for bitvector expressions. `Inst`s can be generated by
the Souper instruction harvester or by hand. The format is designed to
resemble the textual format of LLVM IR in order to make it accessible to
LLVM developers.

A basic `Inst` consists of lines of the form `%v = ...`, where `v` is
any alphanumeric string, which declare instructions named `%v`, followed
by a single line of the form `cand X Y` which denotes a possible rewrite
from `X` to `Y`. A simple example of an `Inst` is given below:

``` {.sourceCode .text}
%a:i32 = var
%aa = add %a, %a
%2a = mul %a, 2
cand %aa %2a
```

This pattern states that instructions of the form `%aa = add %a, %a`,
where `%a` is an arbitrary instruction of 32-bit integer type, can be
rewritten as `%2a = mul %a, 2`.

It is also possible to express path conditions in `Inst`s. Path
conditions are of the form of either `pc X Y` or `blockpc b i X Y`.

The first form express that the relation `X = Y` must hold in order for
the transformation to be valid. The harvester derives path conditions
from control flow. For example, in the following C program:

``` {.sourceCode .c}
void f(int x) {
  if (x > 2) {
    g(x > 1);
  }
}
```

the expression `x > 1` is evaluated in a context where it is known that
`x > 2` holds, and hence we can simplify this to `true`. This is how we
might express this as a Souper `Inst`:

``` {.sourceCode .text}
%x:i32 = var
%2lx = slt 2, %x
pc %2lx 1
%1lx = slt 1, %x
cand %1lx 1
```

The second form expresses that the relation `X = Y` holds on the `ith`
incoming path of the given block `b`, where `i` is zero-based. For
example, in the C program below:

``` {.sourceCode .c}
int foo (int a) {
  int c;
  if (a == 0) {
    c = a + 1;
  } else {
    c = 1;
  }
  return c == 2;
}
```

the expression `c == 2` can be evaluated based on the values of `c` from
both of the incoming paths. In souper, we might express this as:

``` {.sourceCode .text}
%0 = block 2
%1:i32 = var
%2:i1 = eq 0:i32, %1
blockpc %0 0 %2 1:i1
blockpc %0 1 %2 0:i1
%3:i32 = addnsw 1:i32, %1
%4:i32 = phi %0, %3, 1:i32
%5:i1 = eq 1:i32, %4
cand %5 1:i1
```

Instructions
------------

The available instructions are listed below. Most have straightforward
semantics, but some deserve a more detailed explanation which is linked
to from the table.

| Name     | Meaning                                                               |
|----------|-----------------------------------------------------------------------|
| `var`    | Unconstrained value                                                   |
| `block`  | Basic block                                                           |
| `phi`    | Phi node                                                              |
| `add`    | Integer addition                                                      |
| `addnsw` | Integer addition, signed wrap is undefined                            |
| `sub`    | Integer subtraction                                                   |
| `subnsw` | Integer subtraction, signed wrap is undefined                         |
| `mul`    | Integer multiplication                                                |
| `udiv`   | Unsigned integer division                                             |
| `sdiv`   | Signed integer division                                               |
| `urem`   | Unsigned integer remainder                                            |
| `srem`   | Signed integer remainder                                              |
| `and`    | Binary and                                                            |
| `or`     | Binary or                                                             |
| `xor`    | Binary xor                                                            |
| `shl`    | Shift left                                                            |
| `lshr`   | Logical shift right (zero fill)                                       |
| `ashr`   | Arithmetic shift right (sign bit fill)                                |
| `select` | Selection between second and third operands based on first operand    |
| `zext`   | Zero extend                                                           |
| `sext`   | Sign extend                                                           |
| `trunc`  | Truncation                                                            |
| `eq`     | Integer equality                                                      |
| `ne`     | Integer non-equality                                                  |
| `ult`    | Unsigned integer less than                                            |
| `slt`    | Signed integer less than                                              |
| `ule`    | Unsigned integer less than or equal to                                |
| `sle`    | Signed integer less than or equal to                                  |

It is not necessary to specify a type for most instructions, as it can
be inferred from the operands. However, the types of the instructions
`var`, `zext`, `sext` and `trunc` cannot be inferred and it is necessary
to specify the type manually by starting the line with `%var:iN = ...`
where `N` is the desired bit width.

Operands to instructions, `cand`, `pc` and `blockpc` may be of the form
`%v`, `X` or `X:iN`, where `v` is an alphanumeric string referring to a
previously defined instruction, `X` is a (possibly negative) integer
literal and `N` is the constant\'s bit width. It is not necessary to
specify a constant\'s bit width unless the instruction has no other
operands which may be used to infer the width.

The associative instructions `add`, `mul`, `and`, `or` and `xor` may be
written with two or more operands as shorthand for manually chaining the
operations.

### Basic blocks and phi nodes {#phinode}

Convergent control flow is represented in `Inst` using two constructs:
basic blocks and phi nodes. A basic block, written as `%name = block n`,
represents a basic block, or more specifically the control flow of a
basic block relative to its predecessors, where `n` is its number of
predecessors. Basic blocks appear as the first operand in a phi node,
which may have any number of additional operands which represent values
from predecessors of the block (however the number of operands must be
consistent between phi nodes which use a specific block); the basic
block controls which predecessor value is selected. For example:

``` {.sourceCode .text}
%bb = block 3
%phi1 = phi %bb, 1:i32, 2, 3
%phi2 = phi %bb, 2:i32, 4, 6
%phi1x2 = mul %phi1, 2
cand %phi2 %phi1x2
```

This is a valid `Inst` which describes a pair of phi nodes in a basic
block with three predecessor blocks. The relation between %phi2 and
%phi1x2 holds because the first operand %bb constrains %phi1 and %phi2
such that they will be evaluated with the same operand, so they may only
have the values 1 and 2, 2 and 4 or 3 and 6 respectively.

### Undefined behavior {#undef}

Certain instructions, currently `addnsw` and `subnsw`, have undefined
behavior in certain cases. Instructions with undefined behavior are
treated similarly to [poison
values](http://llvm.org/docs/LangRef.html#poison-values) in LLVM.
Specifically, if an instruction triggers undefined behavior, the
instruction and each of its (direct or indirect) users is considered a
poison value. Souper may substitute a poison value with any value of its
choosing. For example, the following `Inst` is valid:

``` {.sourceCode .text}
%x:i32 = var
%add = addnsw %x, 1
%cmp = slt %x, %add
cand %cmp 1
```

This is because the only value of `%x` which would normally not satisfy
the `%cmp` relation is 2^31^-1, which causes the `%add` operation to
wrap and hence become a poison value, and thus so would `%cmp`.

There is currently a known unsoundness issue with the current
implementation of undefined behavior in Souper. Per the LLVM poison
value rules, poison values are not propagated through untaken
predecessors of phi nodes. However, because Souper currently propagates
such poison values, it is possible for invalid transformations to be
deemed valid if an untaken phi node predecessor may exhibit undefined
behavior.
